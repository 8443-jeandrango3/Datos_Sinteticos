# -*- coding: utf-8 -*-
"""[NRC_8393]_Lab1Unidad1_AndrangoCasamin_JessicaEstefania

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IoCaiwM9E8kvwFvBY7umxae6k3_7xhX8
"""

# Importamos librerias 
import pandas as pd
import uuid
import random
from faker import Faker
import datetime
num_users = 5000
features = [
    "id",
    "Genero",
     "name",
    "email",
    "dob",
    "education",
    "bio",
    "rating"
    ]
# Crear el dataframe con los features 
df = pd.DataFrame(columns=features)

df['id'] = [uuid.uuid4().int for i in range(num_users)]
#Verifca que los id sean unicos 
print(df['id'].nunique()==num_users)
#Declaramos la variable genders para crear una lista de opciones 
genders = ["male", "female", "na"]

#Se define en donde se desea cargar la lista 
#Se proporciona la cantidad de datos que se desea observar de cada uno.
#Llama a la variable que almacena la cantidad de datos deseados.
df['Genero'] = random.choices(genders , weights=(47,47,6),  k=num_users)

#utilizamos la libreria faker para generar nombres falsos 
faker = Faker()
#Creamos una funcion llamada name_gen 
def name_gen(Genero):
#Hacemos una condicional si genero es masculino el nombre debe ser masculino 
    if Genero=='male':
       return faker.name_male()
#Hacemos una condicional si genero es femenino el nombre debe ser femenino
    elif Genero=='female':
        return faker.name_female()
        return faker.name()
#Guardamos los datos dentro de nuestro df y nuestro elemento name
df['name'] = [name_gen(i) for i in df['Genero']]


#Creamos una funcion para validar que los correos no se repitan 
def emailGen(name, duplicateFound=False):
#Definimos la estructura de los correos
    dom = "@fakemail.com"
    name = name.lower().split( )
    chars = [".", "_"]
#Si existen nombre repetidos se va a aumentar un numero al nombre
    new_name = name[0] + random.choice(chars) + name[1]
    if duplicateFound:
      num = random.randint(0,100)
      new_name = new_name + str(num)
#la funcion regresa una cadena concatenada 
    return new_name + dom
#Se declara la variable para cargar los datos 
    emails = []
    for name in df['name']:
      email = emailGen(name)
    while email in emails:
      email = emailGen(name, duplicateFound=True)
      emails.append(email)
df['email'] = emails
  

def random_dob(start, end, n):
#Formato de la fecha 
  frmt = "%Y-%m-%d"
# Formatear los periodos de tiempo 
  stime = datetime.datetime.strptime(start, frmt)
  etime = datetime.datetime.strptime(end, frmt)
# Crea el grupo de tiempo aleatorio
  td = etime - stime
 # Genera una lista ramdon de fechas 
  times = [(random.random() * td + stime).strftime(frmt) for _ in range(n)]
  return times
 #se van a tomar las fechas desde  1980 hasta 2006
df['dob'] = random_dob("1980-01-01", "2006-01-01", num_users)

  
# Lee la fecha actual 
  now = datetime.datetime.now()
# Fecha de nacimiento para correlacionar con la edad 
  dob = datetime.datetime.strptime(random_dob,"%Y-%m-%d")
# Restando los tiempos para obtener una edad
  age = int((now - random_dob).days/365.25)
# Regresa el nivel de educacion basado en la edad 
  if age <= 18:
    return 'high school'
  elif age <= 22:
    return 'undergrad'
  elif age <= 25:
    return 'grad'
  else:
    return 'employed'
  df['education'] = [getEducation(i) for i in df['dob']]
  print(df)
df.to_csv('dataset_users.csv')

def getEducation(random_dob):
# Current date
  now = datetime.datetime.now()
# Date of birth
  dob = datetime.datetime.strptime(dob,"%Y-%m-%d")
# Subtracting the times to get an age
  age = int((now -dob).days/365.25)
# Returning education level based on age
  if age <= 18:
    return 'high school'
  elif age <= 22:
    return 'undergrad'
  elif age <= 25:
    return 'grad'
  else:
    return 'employed'
  df['education'] = [getEducation(i) for i in df['dob']]
print(df)

!pip install Faker

from pandas.io.formats.style_render import uuid4
from re import X
# Importamos librerias 
import pandas as pd
import uuid
import random
from faker import Faker
import datetime
num_users = 5000
#sum=0
features = [
    "id",
    "Genero",
     "name",
    "email",
      "T.Beneficiario",
    "dob",
    "education",
    "bio",
  
    ]
# Crear el dataframe con los features 
df = pd.DataFrame(columns=features)


def ced(uuid4):
    l = len(uuid4)
    if l == 10 or l == 13: # verificar la longitud correcta
        cp = int(uuid4[0:2])
        if cp >= 1 and cp <= 22: # verificar codigo de provincia
            tercer_dig = int(uuid4[2])
            if tercer_dig >= 0 and tercer_dig < 6 : # numeros enter 0 y 6
                if l == 10:
                    return __validar_ced_ruc(uuid4,0)                       
                elif l == 13:
                    return __validar_ced_ruc(uuid4,0) and uuid4[10:13] != '000' # se verifica q los ultimos numeros no sean 000
            elif tercer_dig == 6:
                return __validar_ced_ruc(uuid4,1) # sociedades publicas
            elif tercer_dig == 9: # si es ruc
                return __validar_ced_ruc(uuid4,2) # sociedades privadas
            else:
                raise Exception(u'Tercer digito invalido') 
        else:
            raise Exception(u'Codigo de provincia incorrecto') 
    else:
        raise Exception(u'Longitud incorrecta del numero ingresado')



df['id'] = [ced for l in range(num_users)]


genders = ["male", "female", "na"]
df['Genero'] = random.choices(genders , weights=(47,47,6),  k=num_users)

tb = ["Bono Desarrollo H", "Pension Adultos M ", "Pension mis mejores aÃ±os", "Pension Discapacidad" , "Contingencias"]
df['T.Beneficiario'] = random.choices(tb , weights=(25,35,20,10,10), k=num_users)
print(df)



!pip install Faker