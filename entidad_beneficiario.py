# -*- coding: utf-8 -*-
"""Entidad_Beneficiario.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q2csJQxI5wOvQl9Vx9ltNYNt3Ej0_mmO
"""

!pip install Faker
import pandas as pd
import uuid
import random
from faker import Faker
import datetime

#Numero de datos sinteticos 
num_users = 5000

# Lista de atributos 
features = [
    "id_Be",
    "Genero_Be",
    "name",
    "email",
    "dob",
    "T.Beneficiario",
    "education"

]# Crea el dataframe con la lista de atributos
df = pd.DataFrame(columns=features)

#Utilizamos uuid para generar numeros aleatorios 
df['id_Be'] = [uuid.uuid4().int for i in range(num_users)]

#Verifica que cada numero generado sea único
print(df['id_Be'].nunique()==num_users)

Genero_Bes = ["male", "female", "na"]

df['Genero_Be'] = random.choices(
    Genero_Bes, 
    weights=(47,47,6), 
    k=num_users
)

# Inicializamos Facker para los datos sinteticos
faker = Faker()

def name_gen(Genero_Be):
    """
    Genera el nombre del usuario con respecto al genero 
    ___________
    Tenemos tres opciones definidas como genero 
    male
    female
    na 
    ___________
    Es una función ya que tiene de retorno una de las tres opciones presentadas
    """
    if Genero_Be=='male':
        return faker.name_male()
    elif Genero_Be=='female':
        return faker.name_female()
    
#Genera los datos sinteticos 
    return faker.name()
df['name'] = [name_gen(i) for i in df['Genero_Be']]

def emailGen(name, duplicateFound=False):
    """
    Genera una dirección de correo electrónico aleatoria basada en el name dado.
    Agrega un número al final si se encuentra una dirección duplicada.

    """
    # Nombre de dominio falso 
    dom = "@mies.com"
    
    # Adminitimos Minúsculas y división
    name = name.lower().split(" ")
    
    # Aceptamos caracteres
    chars = [".", "_"]
    
    new_name = name[0] + random.choice(chars) + name[1] 
    
    # Distinguir aún más el correo electrónico si se encontró un duplicado
    if duplicateFound:
        
        # Numero aleatorio si se repiten los nombres
        num = random.randint(0,100)
        
        # Indica que el numero se coloca al final 
        new_name = new_name + str(num)
        
    # Devolviendo la dirección de correo electrónico con el nombre de name adjunto
    return new_name + dom

emails = []

for name in df['name']:
    
    # Generamos el email
    email = emailGen(name)
    
    # Bucle hasta que se genera un correo electrónico único
    while email in emails:
        
        # Crear un correo electrónico con un número aleatorio
        email = emailGen(name, duplicateFound=True)
    
    # Adjuntar el nuevo correo electrónico a la lista
    emails.append(email)
    
df['email'] = emails

def random_dob(start, end, n):
    """
    Generar una lista de un número determinado de marcas de tiempo
    """
    
    # El formato de marca de tiempo
    frmt = "%Y-%m-%d"
    
    # Formateo de los dos períodos de tiempo
    stime = datetime.datetime.strptime(start, frmt)
    etime = datetime.datetime.strptime(end, frmt)
    
    # Creando el grupo para tiempos aleatorios
    td = etime - stime
    
    # Generando una lista con los tiempos aleatorios
    times = [(random.random() * td + stime).strftime(frmt) for _ in range(n)]
    
    return times

df['dob'] = random_dob("1980-01-01", "2006-01-01", num_users)

def getEducation(dob):
    """
    
    Asigna un nivel de educación basado en la fecha de nacimiento dada
    """
    # Fecha actual
    now = datetime.datetime.now()
    
    # Fecha de cumpleaños
    dob = datetime.datetime.strptime(dob, "%Y-%m-%d")
    
    # Restando los tiempos para obtener una edad
    age = int((now - dob).days/365.25)
    
    # Nivel de educación que regresa basado en la edad
    if age <= 18:
        return 'high school'
    elif age <= 22:
        return 'undergrad'
    elif age <= 25:
        return 'grad'
    else:
        return 'employed'

df['education'] = [getEducation(i) for i in df['dob']]

tb = ["Bono Desarrollo Humano", "Pension Adultos Mayores", "Pension mis mejores años", "Pension Discapacidad" , "Contingencias"]
df['T.Beneficiario'] = random.choices(tb , weights=(25,35,20,10,10), k=num_users)

df.to_csv('dataset_users.csv')